<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for HTML5 for Linux version 5.2.0">
  <meta http-equiv="Content-Type" content=
  "text/html; charset=iso-8859-1">
  <meta name="viewport" content=
  "width=device-width, initial-scale=1.0">
  <meta name="referrer" content="no-referrer">
  <link rel="shortcut icon" href="favicon.ico">
  <link rel="stylesheet" href="leaflet.css">
  <link rel="stylesheet" href="leaflet.locate.min.css">
  <style type="text/css">
            #map {
                position: absolute;
                left: 0;
                right: 0;
                top: 0;
                bottom: 0;
            }
            #filter-control {
                background-image: url(images/filter-2x.png);
                background-size: 26px 26px;
            }
            #airspace-stack {
                position: absolute;
                right: 10px;
                top: 10px;
                width: 200px;
                max-height: 80vh;
                overflow-y: auto;
                background: rgba(255, 255, 255, 0.95);
                border: 2px solid #333;
                border-radius: 5px;
                padding: 5px;
                font-family: Arial, sans-serif;
                font-size: 12px;
                box-shadow: 0 0 15px rgba(0,0,0,0.3);
                z-index: 1000;
                display: none;
            }
            .airspace-box {
                border: 2px solid #333;
                border-radius: 3px;
                padding: 8px;
                margin: 3px 0;
                text-align: center;
                font-weight: bold;
                cursor: pointer;
                color: #000;
            }
            .airspace-box:hover {
                opacity: 0.8;
            }
            .altitude-separator {
                display: flex;
                text-align: center;
                color: #000;
                font-size: 11px;
                padding: 0;
                margin: 0;
                font-weight: normal;
            }
            .altitude-separator-left,
            .altitude-separator-right {
                flex: 1;
                padding: 3px 5px;
                border: 1px solid #999;
            }
            .altitude-separator-left {
                text-align: right;
                border-right: 1px solid #333;
            }
            .altitude-separator-right {
                text-align: left;
            }
            #airspace-stack-title {
                text-align: center;
                font-weight: bold;
                color: #000;
                border-bottom: 1px solid #999;
                padding-bottom: 5px;
                margin-bottom: 5px;
            }
            .altitude-bound {
                text-align: center;
                color: #000;
                font-size: 12px;
                font-weight: bold;
                padding: 5px 0;
                border-top: 2px solid #666;
                border-bottom: 2px solid #666;
                margin: 3px 0;
            }
  </style>
  <title>luftrom.info - Norwegian airspace for PG pilots</title>
</head>
<body>
  <div id="map"></div>
  <div id="airspace-stack">
    <div id="airspace-stack-title">Airspace Stack</div>
    <div id="airspace-stack-content"></div>
  </div>
  <script src="https://code.jquery.com/jquery-3.3.1.min.js">
  </script>
  <script src="leaflet.js">
  </script>
  <script src="leaflet.ajax.min.js">
  </script>
  <script src="leaflet.viewpoint.min.js">
  </script>
  <script src="leaflet.locate.min.js">
  </script>
  <script src="leaflet.hash.min.js">
  </script>
  <script src="https://use.fontawesome.com/17dabc76c0.js">
  </script>
  <script type="text/javascript">
            (function() {
                'use strict';

                var luftrom='https://rawcdn.githack.com/relet/pg-xc/2168afb01680af7dd80c9e8aef7917485dfca01a/geojson/luftrom.geojson?min=1';
                var takeoffs='https://rawcdn.githack.com/relet/pg-xc/d1ae085186641a78295956fbf2dad26345af8c2f/geojson/takeoffs.geojson?min=1';

                var shorthash = function(s) {
                    return Math.abs((s+"_salt").split("").reduce(function(a,b){a=(a*33)^b.charCodeAt(0);return a},0)).toString(36);
                };

                var map = L.map('map').setView([65.5, 17.0], 4);

                var i, layer;
                var airspace = {};
                var allAirspaceFeatures = []; // Store all airspace features for stack calculation

                var big_notam=300000;

                var allMapLayers = {
                }
                var baseLayers = {
                }

                var l_osm = L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors',
                });
                baseLayers["World: OpenStreetMap"] = l_osm;
                allMapLayers["osm"] = l_osm;

                var l_topo = L.tileLayer('https://cache.kartverket.no/v1/wmts/1.0.0/topo/default/webmercator/{z}/{y}/{x}.png', {
                    attribution: '&copy; <a href="http://kartverket.no/">Kartverket</a>',
                });
                baseLayers["Norway: Topography"] = l_topo;
                allMapLayers["topo"] = l_topo;

                var l_grey = L.tileLayer('https://cache.kartverket.no/v1/wmts/1.0.0/topograatone/default/webmercator/{z}/{y}/{x}.png', {
                    attribution: '&copy; <a href="http://kartverket.no/">Kartverket</a>',
                });
                baseLayers["Norway: Topography (grey)"] = l_grey;
                allMapLayers["grey"] = l_grey;


                var plugify = function(text) {
                  text = text.toLowerCase();
                  if (text.includes('tma')) text=text.substring(0, text.indexOf('tma')+3);
                  if (text.includes('tia')) text=text.substring(0, text.indexOf('tia')+3);
                  if (text.includes('tiz')) text=text.substring(0, text.indexOf('tiz')+3);
                  if (text.includes('cta')) text=text.substring(0, text.indexOf('cta')+3);
                  if (text.includes('ctr')) text=text.substring(0, text.indexOf('ctr')+3);
                  if (text.includes('en d') || text.includes('en r') || text.includes('es d') || text.includes('es r')) {
                    text=text.split(' ').slice(0,2).join('');
                  } else {
                    text = text.split(' ').join('');
                  }
                  return text;
                };

                var onEachFeature_all = function (feature, layer) {
                                 var plug=plugify(feature.properties['name']);

                                 airspace[plug]=(airspace[plug]||[]).concat([layer]);
                                 
                                 // Only store unique features (avoid duplicates from filtered layers)
                                 var featureKey = feature.properties['name'] + '_' + 
                                                  feature.properties['from (m amsl)'] + '_' + 
                                                  feature.properties['to (m amsl)'];
                                 var alreadyExists = allAirspaceFeatures.some(function(item) {
                                     return item.featureKey === featureKey;
                                 });
                                 if (!alreadyExists) {
                                     allAirspaceFeatures.push({
                                         feature: feature, 
                                         layer: layer, 
                                         featureKey: featureKey
                                     });
                                 }
                                 layer.on('mouseover', function() {
                                     this.setStyle({
                                       'weight': 4,
                                       'fillOpacity': 0.4
                                     })})
                                 layer.on('mouseout', function() {
                                     this.setStyle({
                                       'weight': 2,
                                       'fillOpacity': feature.properties['fillOpacity']
                                     })})

                                 var source=feature.properties['source_href'];
                                 var floor = feature.properties['from (m amsl)']+'m above MSL';
                                 var warning=''
                                 if (feature.properties['temporary'] == true) {
                                   var periods = ''
                                   var pfrom = feature.properties['Date from'];
                                   var pto   = feature.properties['Date until'];
                                   var ptime = feature.properties['Time (UTC)'];
                                   for (var i=0; i < pfrom.length; i++) {
                                       periods += pfrom[i]+" - "+pto[i]+" ";
                                       if (ptime != null) {
                                          periods += ptime+" UTC";
                                       }
                                       periods += "<\/br>";
                                   }
                                   warning = '<span style="color:red">TEMPORARY:<\/span><br/>'+periods;
                                 }
                                 if (feature.properties['notam_only'] == 'true') {
					                          warning = '<span style="color:red">ONLY ACTIVE IF NOTAM IS SENT.<\/span><br />';
			                              if (feature.properties['to (m amsl)']==99999) {
				                                warning += 'Please check NOTAM for updated altitude limits.<br />';
				                            }
                                    if (floor == '4114m above MSL') { // magic number
                                        warning += '<b>Floor: Lower limits of controlled airspace</b><br />'
                                    }
                                 }
                                 if (feature.properties['class'] == 'Luftsport') {
                                   warning = '<span style="color:red">AIR SPORT BOX - must be activated before flying.<\/span><br />Contact your local club before flying, or keep to regular airspace limits.<br />';
                                 }
                                 if (feature.properties['class'] == 'Q') {
                                    warning = '<span style="color:orange">DANGER or AIR SPORT<\/span><br />For air sport boxes, contact your local club before flying, or keep to regular airspace limits.<br />';
                                 }
                                 if (feature.properties['name'].indexOf('RMZ')>-1) {
                                    warning = '<span style="color:green">Exceptions to RMZ/TMZ for paraglider and unmanned aircraft.</span><br />';
                                 }
                                 if (floor == '4114m above MSL' && feature.properties['name'] != 'Polaris CTA 11') { // magic
                                   floor = 'Controlled airspace';
                                 }
                                 layer.bindPopup(
                                     '<h2>'+feature.properties['name']+'<\/h2><br />'+warning+
                                     'Class: '+feature.properties['class']+'<br />'+
                                     'Ceiling: '+feature.properties['to (m amsl)']+'m above MSL<br />'+
                                     'Floor: '+floor+'<br />'+
                                     '<a href="'+source+'">Reference<\/a><br />'
                                 );
                };

                var style_all = function(feature) {
                    if (feature.properties['class'] == 'Luftsport') {
                        feature.properties['color'] = '#cc66ff';
                    }
                    if (feature.properties['class'] == 'Q') {
                        feature.properties['color'] = '#8855dd';
                    }
                    return feature.properties;

                };

                var filter_all = function(key, search) {
                    return function(feature) {
                        for (var i = 0; i<search.length; i++) {
                            if (feature.properties[key].indexOf(search[i]) > -1) {
                                return true;
                            }
                        }
                        return false;
                    }
                };

                var onEachFeature_takeoffs = function (feature, layer) {
                        var lon=feature.geometry.coordinates[0];
                        var lat=feature.geometry.coordinates[1];
                        layer.bindPopup('<h2>'+feature.properties['name']+' ('+feature.geometry.coordinates[2]+'m asl)<\/h2>' +
                          'Weather forecast: <a href="http://xcmeteo.net/?p='+lon+'x'+lat+'">XCMeteo<\/a> <a href="https://www.windy.com/'+lat+'/'+lon+'?850h,'+lat+','+lon+',14">Windy</a><br /><br />' +
                                        feature.properties['description'].trim(),
                                        {maxHeight: 250});

                };

                var pointToLayer_takeoffs = function (feature, latlng) {
                        var dirs = feature.properties['directions'];
                        var directions = [];
                        if (dirs['n']) {directions.push(180);}
                        if (dirs['ne']) {directions.push(225);}
                        if (dirs['e']) {directions.push(270);}
                        if (dirs['se']) {directions.push(315);}
                        if (dirs['s']) {directions.push(0);}
                        if (dirs['sw']) {directions.push(45);}
                        if (dirs['w']) {directions.push(90);}
                        if (dirs['nw']) {directions.push(135);}
                        return L.viewpoint(latlng, {
                                directions: directions,
                                radius: 6,
                                fillOpacity: 0,
                                arrow: {
                                    color: '#4444ff',
                                    fillColor: '#4444ff',
                                    fillOpacity: 1.0,
                                    height: 3,
                                    width: 10,
                                    stroke: true

                                }
                        });
                };
                var style_takeoffs = function(feature) {
                };
                var filter_takeoffs = function(winddir) {
                        return function(feature) {
                                if ((feature.geometry.coordinates[2] < 100) ||
                                    (feature.properties['name'].indexOf('PPG') > -1)) {
                                        return false;
                                }
                                if (!winddir) {
                                        return true;
                                }
                                return feature.properties['directions'][winddir];
                        };
                };

                var findFeature = function(name) {
                  return airspace[plugify(name)];
                }
                var onEachFeature_notam = function (feature, layer) {
                        var radius=feature.properties['radius'];
                        var opacity=0.1;
                        if (radius>big_notam) opacity=0;

                        layer.bindPopup('<h2>'+feature.properties['title']+'<\/h2>' +
                                        '<a href="'+feature.properties['src_href']+'">Explain this NOTAM<\/a><br /><br />'+
                                        feature.properties['text'].trim(),
                                        {maxHeight: 400, maxWidth: 600});
                        layer.on('mouseover', function() {
                                     this.setStyle({
                                       'weight': 4,
                                       'fillOpacity': 0.4
                                     });
				     // highlight affected areas of a NOTAM
                                     feature.properties['affected'].forEach(function(s) {
                                       var f = findFeature(s);
                                       if (f) {
                                         for (var i=0; i<f.length; i++) {
                                           f[i].setStyle({
                                             'weight': 4,
                                             'fillOpacity': 0.8
                                           });
                                         };
                                       };
                                     });
                        });
                        layer.on('mouseout', function() {
                                     this.setStyle({
                                       'weight': 2,
                                       'fillOpacity': opacity
                                     });
                                     feature.properties['affected'].forEach(function(s) {
                                       var f = findFeature(s);
                                       if (f) {
                                         for (var i=0; i<f.length; i++) {
                                           f[i].setStyle({
                                             'weight': 2,
                                             'fillOpacity': f[i].feature.properties['fillOpacity']
                                           });
                                         };
                                       };
                                     });
                        });
                };
    var ptl_notam = function(feature, latlng) {
                var radius=feature.properties['radius'];
                var opacity=0.1;
                if (radius>big_notam) opacity=0;
                return L.circle(latlng, radius, {
                                     fillOpacity: opacity,
                                     stroke: true
                });
    }

    var style_notam_shadow = function(feature) {
      var radius=feature.properties['radius'];
      var opacity=0.2;
      if (radius>big_notam) opacity=0;

      return { color: 'gray',
               fillColor: 'gray',
               fillOpacity: opacity,
               stroke: true,
               opacity: 0.5,
               interactive: false
      };
    };

    var ptl_notam_shadow = function(feature, latlng) {
      var radius=feature.properties['radius'];
      return L.circle(latlng, radius, {})
    }

		 <!--
                //TODO: Use geojsonLayer.refilter for filtered layers.
                //"<b>NOTAM<\/b>": new L.GeoJSON.AJAX("https://relet.net/notam", { pointToLayer: ptl_notam, onEachFeature: onEachFeature_notam }),
                //" - indicated only": new L.GeoJSON.AJAX("https://relet.net/notam", { pointToLayer: ptl_notam_shadow, style: style_notam_shadow }),
		-->
                var overLayers = {
                  "<b>Norwegian airspace<\/b>": new L.GeoJSON.AJAX(luftrom, { onEachFeature: onEachFeature_all, style: style_all }),
                  " - CTA (<4200m)": new L.GeoJSON.AJAX(luftrom, { onEachFeature: onEachFeature_all, style: style_all, filter: filter_all('name',['CTA']) }),
                  " - TMA": new L.GeoJSON.AJAX(luftrom, { onEachFeature: onEachFeature_all, style: style_all, filter: filter_all('name',['TMA']) }),
                  " - CTR/TIA/TIZ": new L.GeoJSON.AJAX(luftrom, { onEachFeature: onEachFeature_all, style: style_all, filter: filter_all('name',['CTR','TIA','TIZ']) }),
                  " - Danger/Restricted": new L.GeoJSON.AJAX(luftrom, { onEachFeature: onEachFeature_all, style: style_all, filter: filter_all('class',['R', 'Q']) }),
                  " - Air sport": new L.GeoJSON.AJAX(luftrom, { onEachFeature: onEachFeature_all, style: style_all, filter: filter_all('class',['Luftsport']) }),
                  "<b>Takeoffs<\/b>": new L.GeoJSON.AJAX(takeoffs, { onEachFeature: onEachFeature_takeoffs, style: style_takeoffs , filter: filter_takeoffs(false), pointToLayer: pointToLayer_takeoffs}),
                  " - towards S": new L.GeoJSON.AJAX(takeoffs, { onEachFeature: onEachFeature_takeoffs, style: style_takeoffs , filter: filter_takeoffs('s'), pointToLayer: pointToLayer_takeoffs}),
                  " - towards SE": new L.GeoJSON.AJAX(takeoffs, { onEachFeature: onEachFeature_takeoffs, style: style_takeoffs , filter: filter_takeoffs('se'), pointToLayer: pointToLayer_takeoffs}),
                  " - towards E": new L.GeoJSON.AJAX(takeoffs, { onEachFeature: onEachFeature_takeoffs, style: style_takeoffs , filter: filter_takeoffs('e'), pointToLayer: pointToLayer_takeoffs}),
                  " - towards NE": new L.GeoJSON.AJAX(takeoffs, { onEachFeature: onEachFeature_takeoffs, style: style_takeoffs , filter: filter_takeoffs('ne'), pointToLayer: pointToLayer_takeoffs}),
                  " - towards N": new L.GeoJSON.AJAX(takeoffs, { onEachFeature: onEachFeature_takeoffs, style: style_takeoffs , filter: filter_takeoffs('n'), pointToLayer: pointToLayer_takeoffs}),
                  " - towards NW": new L.GeoJSON.AJAX(takeoffs, { onEachFeature: onEachFeature_takeoffs, style: style_takeoffs , filter: filter_takeoffs('nw'), pointToLayer: pointToLayer_takeoffs}),
                  " - towards W": new L.GeoJSON.AJAX(takeoffs, { onEachFeature: onEachFeature_takeoffs, style: style_takeoffs , filter: filter_takeoffs('w'), pointToLayer: pointToLayer_takeoffs}),
                  " - towards SW": new L.GeoJSON.AJAX(takeoffs, { onEachFeature: onEachFeature_takeoffs, style: style_takeoffs , filter: filter_takeoffs('sw'), pointToLayer: pointToLayer_takeoffs}),
                };

                for (var key in overLayers) {
                    allMapLayers[shorthash(key)]=overLayers[key];
                }

                baseLayers["World: OpenStreetMap"].addTo(map);
                overLayers["<b>Norwegian airspace<\/b>"].addTo(map);

                map.on('overlayadd', function() {
                  overLayers[' - indicated only'].bringToFront();
                  overLayers['<b>NOTAM<\/b>'].bringToFront();
                });

                var hash = new L.Hash(map);

                var lc = L.control.layers(baseLayers, overLayers);
                // close layercontrol on click (fix for android phones)
                document.getElementById('map').addEventListener('click', function(e) {
                    lc.collapse();
                }, false);
                lc.addTo(map);
                L.control.locate({
                    flyTo: true,
                    locateOptions: {
                      maxZoom: 9
                    }
                }).addTo(map);

                // Airspace stack visualization
                var lastMouseLatLng = null;
                var mouseThrottle = null;
                
                // Point-in-polygon test (ray casting algorithm)
                var pointInPolygon = function(point, polygon) {
                    var x = point.lat, y = point.lng;
                    var inside = false;
                    
                    for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                        var xi = polygon[i].lat, yi = polygon[i].lng;
                        var xj = polygon[j].lat, yj = polygon[j].lng;
                        
                        var intersect = ((yi > y) != (yj > y))
                            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                        if (intersect) inside = !inside;
                    }
                    
                    return inside;
                };
                
                var updateAirspaceStack = function(latlng) {
                    var stackDiv = document.getElementById('airspace-stack');
                    var contentDiv = document.getElementById('airspace-stack-content');
                    
                    // Find all airspaces containing this point
                    var containingAirspaces = [];
                    
                    allAirspaceFeatures.forEach(function(item) {
                        var layer = item.layer;
                        var feature = item.feature;
                        
                        // Quick bounding box check first
                        if (!layer.getBounds || !layer.getBounds().contains(latlng)) {
                            return; // Skip if not even in bounding box
                        }
                        
                        // Do precise point-in-polygon check
                        var contains = false;
                        
                        if (layer instanceof L.Circle) {
                            // Circle check: distance from center
                            var distance = map.distance(latlng, layer.getLatLng());
                            contains = distance <= layer.getRadius();
                        } else if (layer instanceof L.Polygon) {
                            // Polygon check: point-in-polygon for each ring
                            var latlngs = layer.getLatLngs();
                            
                            // Handle MultiPolygon (array of arrays of rings)
                            if (latlngs.length > 0 && Array.isArray(latlngs[0])) {
                                // Could be array of polygons or array of rings
                                if (latlngs[0].length > 0 && latlngs[0][0].lat !== undefined) {
                                    // Array of rings (holes)
                                    contains = pointInPolygon(latlng, latlngs[0]);
                                    // Check holes (if any)
                                    for (var h = 1; h < latlngs.length; h++) {
                                        if (pointInPolygon(latlng, latlngs[h])) {
                                            contains = false; // Point is in a hole
                                            break;
                                        }
                                    }
                                } else {
                                    // MultiPolygon - check each polygon
                                    for (var p = 0; p < latlngs.length; p++) {
                                        if (latlngs[p].length > 0 && pointInPolygon(latlng, latlngs[p][0])) {
                                            contains = true;
                                            break;
                                        }
                                    }
                                }
                            } else {
                                // Simple polygon
                                contains = pointInPolygon(latlng, latlngs);
                            }
                        } else if (layer instanceof L.Rectangle) {
                            // Rectangle - getBounds is sufficient
                            contains = true;
                        }
                        
                        if (contains) {
                            containingAirspaces.push({
                                name: feature.properties['name'],
                                class: feature.properties['class'],
                                from: feature.properties['from (m amsl)'],
                                to: feature.properties['to (m amsl)'],
                                color: feature.properties['color'] || '#3388ff',
                                fillOpacity: feature.properties['fillOpacity'] || 0.2,
                                layer: layer
                            });
                        }
                    });
                    
                    if (containingAirspaces.length === 0) {
                        stackDiv.style.display = 'none';
                        return;
                    }
                    
                    // Sort by altitude (highest first)
                    containingAirspaces.sort(function(a, b) {
                        return b.to - a.to;
                    });
                    
                    // Find overall altitude bounds
                    var maxAlt = Math.max.apply(Math, containingAirspaces.map(function(s) { return s.to; }));
                    var minAlt = Math.min.apply(Math, containingAirspaces.map(function(s) { return s.from; }));
                    
                    // Format altitude display
                    var formatAlt = function(alt) {
                        return alt === 0 ? 'GND' : alt + 'm';
                    };
                    
                    // Build the stack visualization
                    var html = '';
                    
                    // Top altitude bound
                    html += '<div class="altitude-bound">^ ' + formatAlt(maxAlt) + '</div>';
                    
                    for (var i = 0; i < containingAirspaces.length; i++) {
                        var space = containingAirspaces[i];
                        var bgColor = space.color;
                        var bgOpacity = space.fillOpacity * 2; // Make it more visible in sidebar
                        if (bgOpacity > 0.8) bgOpacity = 0.8;
                        
                        // Convert hex to rgba for background transparency (keeps text opaque)
                        var rgba = bgColor;
                        if (bgColor.startsWith('#')) {
                            var r = parseInt(bgColor.substr(1,2), 16);
                            var g = parseInt(bgColor.substr(3,2), 16);
                            var b = parseInt(bgColor.substr(5,2), 16);
                            rgba = 'rgba(' + r + ',' + g + ',' + b + ',' + bgOpacity + ')';
                        }
                        
                        // Create airspace box
                        html += '<div class="airspace-box" style="background-color: ' + rgba + ';" ';
                        html += 'data-layer-id="' + i + '">';
                        html += '<div style="font-size: 13px;">' + space.name + '</div>';
                        html += '<div style="font-size: 11px; font-weight: normal;">Class ' + space.class + '</div>';
                        html += '</div>';
                        
                        // Add altitude separator (except after last one)
                        if (i < containingAirspaces.length - 1) {
                            var lowerSpace = containingAirspaces[i + 1];
                            
                            // Convert colors to rgba for transparency
                            var upperRgba = bgColor;
                            if (bgColor.startsWith('#')) {
                                var r = parseInt(bgColor.substr(1,2), 16);
                                var g = parseInt(bgColor.substr(3,2), 16);
                                var b = parseInt(bgColor.substr(5,2), 16);
                                upperRgba = 'rgba(' + r + ',' + g + ',' + b + ',' + bgOpacity + ')';
                            }
                            
                            var lowerColor = lowerSpace.color;
                            var lowerOpacity = lowerSpace.fillOpacity * 2;
                            if (lowerOpacity > 0.8) lowerOpacity = 0.8;
                            var lowerRgba = lowerColor;
                            if (lowerColor.startsWith('#')) {
                                var r2 = parseInt(lowerColor.substr(1,2), 16);
                                var g2 = parseInt(lowerColor.substr(3,2), 16);
                                var b2 = parseInt(lowerColor.substr(5,2), 16);
                                lowerRgba = 'rgba(' + r2 + ',' + g2 + ',' + b2 + ',' + lowerOpacity + ')';
                            }
                            
                            // Left: lower bound of upper airspace, Right: upper bound of lower airspace
                            html += '<div class="altitude-separator">';
                            html += '<div class="altitude-separator-left" style="background-color: ' + upperRgba + ';">';
                            html += formatAlt(space.from);
                            html += '</div>';
                            html += '<div class="altitude-separator-right" style="background-color: ' + lowerRgba + ';">';
                            html += formatAlt(lowerSpace.to);
                            html += '</div>';
                            html += '</div>';
                        }
                    }
                    
                    // Bottom altitude bound
                    html += '<div class="altitude-bound">v ' + formatAlt(minAlt) + '</div>';
                    
                    contentDiv.innerHTML = html;
                    stackDiv.style.display = 'block';
                    
                    // Add click handlers to highlight the airspace
                    var boxes = contentDiv.getElementsByClassName('airspace-box');
                    for (var i = 0; i < boxes.length; i++) {
                        (function(idx) {
                            boxes[idx].addEventListener('click', function() {
                                containingAirspaces[idx].layer.fire('click');
                            });
                        })(i);
                    }
                };
                
                map.on('mousemove', function(e) {
                    lastMouseLatLng = e.latlng;
                    
                    // Throttle updates to every 300ms
                    if (mouseThrottle) {
                        clearTimeout(mouseThrottle);
                    }
                    mouseThrottle = setTimeout(function() {
                        if (lastMouseLatLng) {
                            updateAirspaceStack(lastMouseLatLng);
                        }
                    }, 300);
                });
                
                map.on('mouseout', function() {
                    document.getElementById('airspace-stack').style.display = 'none';
                    if (mouseThrottle) {
                        clearTimeout(mouseThrottle);
                    }
                });

            }());
  </script>
</body>
</html>
